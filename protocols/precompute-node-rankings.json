{"id":41124,"title":"Precompute Node Rankings","title_html":"<p>Precompute Node Rankings<\/p>","image":{"source":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/aff7b00e7745383ae11e3af6080e1953f199d3d515fcb352a9ce52f476b677c2\/ch96bfuzx.png","placeholder":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/aff7b00e7745383ae11e3af6080e1953f199d3d515fcb352a9ce52f476b677c2\/ch96bfuzx.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.bkecktaw","doi_status":2,"uri":"precompute-node-rankings-bkecktaw","type_id":1,"template_id":5,"published_on":1607660625,"parent_protocols":[],"parent_collections":[],"cited_protocols":[],"version_id":0,"version_data":{"id":"0","code":"bkecktaw","parent_id":0,"parent_uri":null,"is_same_owner":false,"has_pending_merge_request":false,"has_approved_merge_request":false},"created_on":1598563346,"modified_on":null,"categories":null,"public":1,"is_unlisted":0,"creator":{"name":"Lillian R. Thistlethwaite","affiliation":"Baylor College of Medicine","affiliations":[{"affiliation":"Baylor College of Medicine","url":"http:\/\/genboree.org\/site\/bioinformatics_research_laboratory","is_default":1}],"username":"lillian-thistlethwaite","note":null,"link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/aff7b00e7745383ae11e3af6080e1953f199d3d515fcb352a9ce52f476b677c2\/ch47bfuzx.jpeg","placeholder":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/aff7b00e7745383ae11e3af6080e1953f199d3d515fcb352a9ce52f476b677c2\/ch47bfuzx.jpeg"},"badges":[{"id":2,"image":{"source":"\/img\/badges\/bronze.svg","placeholder":"\/img\/badges\/bronze.svg"},"name":"Author"},{"id":6,"image":{"source":"\/img\/badges\/accelerator.svg","placeholder":"\/img\/badges\/accelerator.svg"},"name":"Science accelerator"}],"verified":0,"is_verified_user":false,"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"journal":null,"journal_name":null,"journal_link":null,"article_citation":null,"has_versions":0,"link":null,"total_collections":0,"number_of_steps":2,"authors":[{"name":"Lillian Thistlethwaite","affiliation":"Baylor College of Medicine","affiliations":[],"username":"lillian-thistlethwaite","note":null,"link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/aff7b00e7745383ae11e3af6080e1953f199d3d515fcb352a9ce52f476b677c2\/ch47bfuzx.jpeg","placeholder":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/aff7b00e7745383ae11e3af6080e1953f199d3d515fcb352a9ce52f476b677c2\/ch47bfuzx.jpeg"},"badges":[],"verified":1,"is_verified_user":true,"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false}],"versions":[],"groups":[],"is_owner":1,"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"can_claim_authorship":0,"can_accept_authorship":0,"can_be_copied":1,"can_remove_fork":1,"fork_id":null,"url":"https:\/\/www.protocols.io\/view\/precompute-node-rankings-bkecktaw","forks_count":{"private":0,"public":0},"access":{"can_view":1,"can_remove":0,"can_add":0,"can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":1,"can_move":1,"can_move_outside":1,"can_transfer":1,"can_download":1,"is_locked":0},"guid":"6007D880E8AB11EAAD17719411A8055E","state_version_id":241,"steps":[{"id":1015032,"guid":"C3168D10E8AE11EAAD17719411A8055E","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"11FC8E92FF1940FF810B12994CFF1B85","order_id":1,"type_id":6,"title":"Section","source":{"title":"wrapper_ranks.r"}},{"id":1054724,"guid":"EB713434EEFD499EA234485155C8F23A","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">This Protocol should be completed on a computing cluster, ideally. Running node ranks in serial takes a much longer amount of time, depending on the size of the network and the number of starting nodes you want to precompute node ranks for. If you launch a job for each starting node you want node ranks for and then collate those node ranks into one list object, you can process ~500 starting node node rankings in less than 15 minutes. We implement the computation of node ranks using this strategy with the following set-up:<\/div><div class = \"text-block\"># FILE HIERARCHY: <\/div><div class = \"text-block\">#        graphs\/ folder with all bg_[model]_[type]_fold[fold].RData files in it.<\/div><div class = \"text-block\">#        wrapper_ranks.r<\/div><div class = \"text-block\">#        getRanks.pbs<\/div><div class = \"text-block\">#        getRanksN.r<\/div><div class = \"text-block\"># DIRECTIONS: Run wrapper_ranks.r on your computing cluster with for each pruned disease network. Set type=\"ind\" <\/div><div class = \"text-block\">#             since we want the node ranks for the pruned disease-specific network (which uses latent embedding and <\/div><div class = \"text-block\">#             network pruning). type=\"noPruning\" is used for the disease+reference network (no network pruning) and <\/div><div class = \"text-block\">#             type=\"noLatent\" is used for a disease-only network (no latent embedding or network pruning).<\/div><div class = \"text-block\">Rscript wrapper_ranks.r [model] [fold] [type] <\/div><div class = \"text-block\">Rscript wrapper_ranks.r \"CIT\" 1 \"ind\"<\/div><div class = \"text-block\">Rscript wrapper_ranks.r \"CIT\" 2 \"ind\"<\/div><div class = \"text-block\">Rscript wrapper_ranks.r \"CIT\" 3 \"ind\"<\/div><div class = \"text-block\">Rscript wrapper_ranks.r \"CIT\" 4 \"ind\"<\/div><div class = \"text-block\">Rscript wrapper_ranks.r \"CIT\" 5 \"ind\"<\/div><div class = \"text-block\">Rscript wrapper_ranks.r \"CIT\" 6 \"ind\"<\/div><div class = \"text-block\">Rscript wrapper_ranks.r \"CIT\" 7 \"ind\"<\/div><div class = \"text-block\">Rscript wrapper_ranks.r \"CIT\" 8 \"ind\"<\/div><div class = \"text-block\">Rscript wrapper_ranks.r \"CIT\" 9 \"ind\"<\/div><div class = \"text-block\"># etc. for \"MSUD\", \"MMA\", \"PA\" and \"PKU\", too.<\/div><\/div>"}},{"id":1054725,"guid":"7AD4F900E8AF11EAAD17719411A8055E","order_id":2,"type_id":15,"title":"command","source":{"id":7722,"name":"args = commandArgs(trailingOnly=TRUE)\ndiag = args[1]\nfold = as.numeric(args[2])\ntype = args[3]\n\nrequire(igraph)\noutput_dir = sprintf(\".\/diag%s%d\", diag, fold)\nstr = sprintf(\"mkdir %s\", output_dir)\nsystem(str) \n\nrequire(R.utils)\nrequire(igraph)\nif (type==\"noLatent\") {\n  ig = loadToEnv(sprintf(\"..\/graphs\/noLatent_foldNets\/bg_%s_noLatent_fold%d.RData\", tolower(diag), fold))[[\"ig\"]]\n} else if (type==\"ind\") {\n  ig = loadToEnv(sprintf(\"..\/graphs\/ind_foldNets\/bg_%s_ind_fold%d.RData\", tolower(diag), fold))[[\"ig_pruned\"]]\n} else {\n  ig = loadToEnv(sprintf(\"..\/graphs\/ind_foldNets\/bg_%s_ind_fold%d.RData\", tolower(diag), fold))[[\"ig\"]]\n}\ntotalN = length(V(ig)$name)\nprint(sprintf(\"Total N = %d\", totalN))\n\nfor (n in 1:totalN) {\n  str = sprintf(\"qsub -v diag=%s,fold=%d,n=%d getRanks.pbs\", diag, fold, n)\n  system(str, wait=FALSE)\n  system(\"sleep 0.2\")\n}\n  \nready=FALSE\nlast_sum = 0\nwhile (!ready) {\n  f = list.files(sprintf(\".\/diag%s%d\", diag, fold), pattern=\".RData\")\n  print(sprintf(\"#permutation files ready = %d\", length(f)))\n  if (length(f)==totalN) {\n    ready=TRUE\n  } else {\n    system(\"sleep 20\")\n    system(\"rm *.pbs.*\")\n    curr_sum = length(f)\n    if (curr_sum > last_sum) {\n      last_sum = curr_sum\n    } \n  }\n}\nsystem(\"rm *.pbs.*\")\n  \n# collate permutations into one R object\nall_nodes = V(ig)$name\npermutationByStartNode = list()\nfor (n in 1:length(all_nodes)) {\n  load(sprintf(\".\/diag%s%d\/%d.RData\", diag, fold, n))\n  permutationByStartNode[[n]] = toupper(current_node_set)\n}\nnames(permutationByStartNode) = all_nodes\nsave.image(file=sprintf(\"%sRanks_miller\/%s%d-ranks.RData\", type, toupper(diag), fold))\nprint(\"collate complete...\")\nstr = sprintf(\"rm -r .\/diag%s%d\", diag, fold)\nsystem(str)","command_name":"wrapper_ranks.r","command":"This is the wrapper_ranks.r R code, which uses a PBS job launcher qsub protocol to send an Rscript command to the head node of a computing cluster. If you use a different job launcher protocol, you can substitute the sprintf() command pasted below for the appropriate job launcher syntax that works for your computing cluster set-up:\n\n  str = sprintf(\"qsub -v diag=%s,fold=%d,n=%d,type=%s getRanks.pbs\", diag, fold, n, type)","os_name":null,"os_version":null}}],"cases":[],"data":null,"html":null,"section":null,"section_color":"#A492FF","section_duration":900,"critical":null,"critical_id":null,"duration":900},{"id":1015678,"guid":"DA0FF060E94E11EAAD17719411A8055E","previous_id":1015032,"previous_guid":"C3168D10E8AE11EAAD17719411A8055E","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"6A0BAF0AA81140AB961A94D5FD835764","order_id":1,"type_id":6,"title":"Section","source":{"title":"getRanks.*"}},{"id":1054724,"guid":"E8D27F13FF22441D9A1DB783C64E71FD","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><\/div>"}},{"id":1054725,"guid":"256AB5E0E94F11EAAD17719411A8055E","order_id":2,"type_id":15,"title":"command","source":{"id":7724,"name":"# Request 1 processors on 1 node\n#PBS -l nodes=1:ppn=1\n#Request x number of hours of walltime\n#PBS -l walltime=1:00:00\n#Request that regular output and terminal output go to the same file\n#PBS -j oe\n#PBS -m abe\n# Load R version 4.0\nmodule load R\/4.0\n# Go to wherever your files are on your cluster\ncd metabolomics\/singleNodeRanks\ndiag=${diag}\nfold=${fold}\nn=${n}\ntype=${type}\nRscript getRanksN.r $diag $fold $n $type > ranks:$diag-$fold-$n-$type.out\nrm ranks:$diag-$fold-$n-$type.out","command_name":"getRanks.pbs","command":"This is the PBS launcher script that gets called by wrapper_ranks.r. If your computing cluster uses a different job launcher protocol, you'll use a different file type for this step.","os_name":null,"os_version":null}},{"id":1054726,"guid":"F8B5B400E94E11EAAD17719411A8055E","order_id":3,"type_id":15,"title":"command","source":{"id":7723,"name":"require(igraph)\nargs = commandArgs(trailingOnly=TRUE)\ndiag = args[1]\nfold = as.numeric(args[2])\nn = as.numeric(args[3])\ntype = args[4]\n\nprint(diag)\nprint(fold)\nprint(n)\nprint(type)\n\nrequire(CTD)\nrequire(R.utils)\nif (type==\"noLatent\") {\n  ig = loadToEnv(sprintf(\"..\/graphs\/noLatent_foldNets\/bg_%s_noLatent_fold%d.RData\", tolower(diag), fold))[[\"ig\"]]\n} else if (type==\"ind\") {\n  ig = loadToEnv(sprintf(\"..\/graphs\/ind_foldNets\/bg_%s_ind_fold%d.RData\", tolower(diag), fold))[[\"ig_pruned\"]]\n} else {\n  ig = loadToEnv(sprintf(\"..\/graphs\/ind_foldNets\/bg_%s_ind_fold%d.RData\", tolower(diag), fold))[[\"ig\"]]\n}\nprint(ig)\nV(ig)$name = tolower(V(ig)$name)\nG = vector(mode=\"list\", length=length(V(ig)$name))\nnames(G) = V(ig)$name\nadj_mat = as.matrix(get.adjacency(ig, attr=\"weight\"))\np1=0.9\nthresholdDiff=0.01\nall_nodes = tolower(V(ig)$name)\nprint(head(all_nodes))\ncurrent_node_set = singleNode.getNodeRanksN(n, G, p1, thresholdDiff, adj_mat)\nnew_dir =  sprintf(\".\/diag%s%d\", diag, fold)\nif (!dir.exists(new_dir)) {\n  str = sprintf(\"mkdir %s\", new_dir)\n  system2(str)\n}\nsave(current_node_set, file=sprintf(\".\/diag%s%d\/%d.RData\", diag, fold, n))","command_name":"getRanksN.r","command":"This is the R code for the getRanksN.r that gets called by getRanks.pbs.","os_name":null,"os_version":null}}],"cases":[],"data":null,"html":null,"section":null,"section_color":"#94EBFF","section_duration":60,"critical":null,"critical_id":null,"duration":60}],"document":"","materials":[{"id":580452,"mol_weight":0,"name":"NONE","linfor":"","url":"http:\/\/N\/A","sku":"N\/A","cas_number":"","rrid":"N\/A","public":0,"vendor":{"name":"Contributed by users","affiliation":null,"affiliations":[],"username":null,"note":null,"link":"https:\/\/www.protocols.io","image":{"source":"https:\/\/www.protocols.io\/img\/vendors\/1.png","placeholder":"https:\/\/www.protocols.io\/img\/vendors\/1.png"},"badges":[],"verified":0,"is_verified_user":false,"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false,"id":1},"can_edit":0,"stats":{"total_protocols":0}}],"description":"<div class = \"text-blocks\"><div class = \"text-block\">This protocol describes how probability diffusion algorithm informs the path a network walker takes in a disease-specific network as described in Thistlethwaite et al. (2020). Briefly, using a probability diffusion walker, a network walker decides which nodes to step into, until a specified node subset has been found, or a given number of \"missteps\" occur.<\/div><div class = \"text-block\">Thistlethwaite L.R., Petrosyan V., Li X., Miller M.J., Elsea S.H., Milosavljevic A. (2020). CTD: an information-theoretic method to interpret multivariate perturbations in the context of graphical models with applications in metabolomics and transcriptomics. In review.<\/div><\/div>","changed_on":1607660625}