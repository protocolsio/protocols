{"access":{"can_view":true,"can_edit":false,"can_remove":true,"can_add":false,"can_publish":false,"can_get_doi":true,"can_share":true,"can_move":true,"can_move_outside":true,"can_transfer":true,"can_download":true,"is_locked":false},"authors":[{"name":"Scott  Ferguson","affiliation":"Australian National University","affiliation_url":"scott.ferguson@anu.edu.au","username":"scott-ferguson","link":"","image":{"source":"/img/avatars/017.png","placeholder":"/img/avatars/017.png","webp_source":""},"note":null,"is_verified_author":true,"is_verified_user":true},{"name":"Ashley  Jones","affiliation":"Australian National University","affiliation_url":"","username":"ashley-jones","link":"","image":{"source":"https://s3.amazonaws.com/protocols-files/files/dzan222e.jpg","placeholder":"https://s3.amazonaws.com/protocols-files/files/dzan222e.jpg","webp_source":"https://s3.amazonaws.com/protocols-files/files/dzam222e.webp"},"note":null,"is_verified_author":true,"is_verified_user":true},{"name":"Justin  Borevitz","affiliation":"Australian National University","affiliation_url":null,"username":"w213b403p2t2","link":null,"image":{"source":"/img/avatars/014.png","placeholder":"/img/avatars/014.png","webp_source":""},"note":null,"is_verified_author":true,"is_verified_user":false}],"before_start":"","book_chapter":null,"can_accept_authorship":false,"can_be_copied":true,"can_claim_authorship":false,"can_remove_fork":false,"can_sign":false,"child_steps":{},"cited_protocols":[],"collection_items":[],"created_on":1642052920,"creator":{"name":"Scott Ferguson","affiliation":"Australian National University","affiliation_url":"scott.ferguson@anu.edu.au","username":"scott-ferguson","link":"","image":{"source":"/img/avatars/017.png","placeholder":"/img/avatars/017.png","webp_source":""},"badges":[{"id":3,"name":"Power author!","image":{"source":"/img/badges/silver.svg","placeholder":"/img/badges/silver.svg"}}],"affiliations":[{"affiliation":"Australian National University","url":"scott.ferguson@anu.edu.au","is_default":true}]},"description":"{\"blocks\":[{\"key\":\"j2hs\",\"text\":\"With the introduction of long-read, third generation sequencing (e.g. Oxford Nanopore Technologies (ONT) and Pacific Biosciences (PacBio) and associated bioinformatics tools, we can now affordably assemble complex plant genomes with an accuracy and contiguity that was previously incredibly expensive to obtain. Long-read sequencing technology has dramatically improved our ability to generate de novo genome assemblies. In particular plant genomes, due to their large proportion of repetitive sequences, have highly benefited from long-read sequencing. Despite these improvements, challenges still remain in performing de novo assembly, namely in developing a reliable workflow and in tool choice. Here we present the de novo assembly proportion of our long-read plant genome assembly, scaffolding, and annotation workflow. We have developed and tested this workflow on many complex plant genomes. By using this workflow with a sufficient coverage of long-reads, a highly contiguous and accurate plant genome can be assembled.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[{\"style\":\"italic\",\"offset\":719,\"length\":7}],\"entityRanges\":[],\"data\":{}}],\"entityMap\":{}}","disclaimer":"","document":"","documents":[],"doi":null,"doi_status":0,"fork_id":null,"fork_info":null,"forks":[],"funders":[],"groups":[],"guid":"7598BBBB743411ECBCC40A58A9FEAC02","guidelines":"","has_references":false,"has_versions":true,"id":56861,"image":{"source":"https://s3.amazonaws.com/protocols-files/files/gc83bmnvf.jpg","webp_source":"https://s3.amazonaws.com/protocols-files/files/gc82bmnvf.webp","placeholder":"","webp_placeholder":""},"image_attribution":"","in_trash":true,"is_bookmarked":false,"is_contact_suspended":false,"is_content_confidential":false,"is_content_warning":false,"is_in_transfer":false,"is_owner":true,"is_retracted":false,"is_shared_directly":false,"is_subprotocol":null,"is_unlisted":false,"item_id":863509,"journal":null,"journals":[],"keywords":null,"last_modified":1642054142,"link":"","location":null,"manuscript_citation":"","materials":[],"materials_text":"","ownership_history":null,"parent_collections":[],"parent_protocols":[],"peer_reviewed":false,"public":true,"public_fork_note":"","published_on":1642054142,"references":[],"related_equipments":[],"retraction_reason":null,"shared_access_id":1,"show_comparison":true,"sign_info":null,"state_version_id":18,"stats":{"is_voted":false,"number_of_views":37,"number_of_steps":25,"number_of_bookmarks":0,"number_of_comments":0,"number_of_bookmarked_comments":0,"number_of_steps_comments":0,"number_of_protocol_comments":0,"number_of_exports":0,"number_of_runs":0,"number_of_votes":0,"number_of_reagents":0,"number_of_equipments":0,"number_of_collections":0,"number_of_forks":{"private":0,"public":0},"number_of_accessible_forks":0},"status":{"id":1,"info":"We use this protocol and it’s working"},"steps":[{"id":1318743,"guid":"75AE4BD7743411ECBCC40A58A9FEAC02","previous_id":null,"previous_guid":null,"section":"\u003cp\u003eData Input\u003c/p\u003e","section_color":"#A492FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"ovu6\",\"text\":\"De novo genome assembly works best if long-read sequencing has been performed. For best results, optimise a high-molecular weight DNA extraction, for example we use: High-molecular weight DNA extraction, clean-up and size selection for long-read sequencing (https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0253830).\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":258,\"length\":73}],\"data\":[]},{\"key\":\"8d8d0\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"7c3d\",\"text\":\"Perform long-read sequencing according to manufacturer's instructions and obtain sequence fast5 and (if provided) fastq files.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"link\",\"mutability\":\"\",\"data\":{\"guid\":\"B5542EE071A811EC96210A58A9FEAC02\",\"url\":\"https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0253830\"}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318716,"number":"1","cases":[],"critical":null},{"id":1318744,"guid":"75AE744E743411ECBCC40A58A9FEAC02","previous_id":1318743,"previous_guid":"75AE4BD7743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eData Input\u003c/p\u003e","section_color":"#A492FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"90vj8\",\"text\":\"During the assembly of a genome we often want to count the number of sequences, and length of sequences within a fasta/q. The following script makes use of bioawk (bioawk will need to be in your path) to list all sequence names and sizes in a tab delimited file.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"1i7mt\",\"text\":\"Save this script as gne-file.sh, make it executable (chmod u+x gne-file.sh), and place it in a location included in your path.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"3sdj3\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"232t9\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"gne-file.sh\",\"description\":null,\"guid\":\"3C6FA0E0F58B11EBA3C4A369B741994D\",\"id\":9907,\"name\":\"#!/bin/bash\\necho $1\\ntmp=$(basename $1)\\nfileName=${tmp%.fast*}\\nbioawk -c fastx '{print $name, length($seq)}' $1 \\u003e ${fileName}.genome\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318717,"number":"2","cases":[],"critical":null},{"id":1318745,"guid":"75AE998B743411ECBCC40A58A9FEAC02","previous_id":1318744,"previous_guid":"75AE744E743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eBasecalling\u003c/p\u003e","section_color":"#94EBFF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"mk8u\",\"text\":\"While fastqs may be provided with your fast5 files, due to rapid improvements in the basecaller, it can be greatly beneficial to re-basecall. More recent basecallers, eg. guppy version 5, have a very low per-base error rate, resulting in more contagious assemblies.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"8hqgp\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"bg5ef\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Base call fast5 with guppy v5\",\"description\":null,\"guid\":\"1E1F1DB0F4D111EB9E21AFF8AFFFF59C\",\"id\":9908,\"name\":\"## pick appropriate config file\\n#MinION/GridION + r9.4.1   = dna_r9.4.1_450bps_sup.cfg \\n#MinION/GridION + r10.3    = dna_r10.3_450bps_sup.cfg\\n#PromethION     + r9.4.1   = dna_r9.4.1_450bps_sup_prom.cfg\\n#PromethION     + r10.3    = dna_r10.3_450bps_sup.cfg\\nCFG=XXX.cfg\\n\\n/path to guppy v5+/bin/guppy_basecaller \\\\\\n    -c $CFG \\\\\\n    --input_path /path to fast5 files/ \\\\\\n    --save_path /path to save to/ \\\\\\n    --records_per_fastq 0 \\\\\\n    --device \\\"cuda ID\\\" \\\\\\n    --recursive \\\\\\n    --disable_pings \\\\\\n    --disable_qscore_filtering\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318718,"number":"3","cases":[],"critical":null},{"id":1318746,"guid":"75AEBD42743411ECBCC40A58A9FEAC02","previous_id":1318745,"previous_guid":"75AE998B743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eBasecalling\u003c/p\u003e","section_color":"#94EBFF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"b64i6\",\"text\":\"After basecalling, concatenate all fastq files into a single file and compress with gzip. \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"78kgj\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"b5gcu\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Concatenate all fastq files and gzip\",\"description\":null,\"guid\":\"8927C3D0F4D811EB9E21AFF8AFFFF59C\",\"id\":9909,\"name\":\"find /path Guppy saved fastqs to/ -name ‘*.fastq’ | xargs cat | gzip \\u003e reads.fastq.gz\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318719,"number":"4","cases":[],"critical":null},{"id":1318747,"guid":"75AEDE5D743411ECBCC40A58A9FEAC02","previous_id":1318746,"previous_guid":"75AEBD42743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eRead trimming and preliminary filtering\u003c/p\u003e","section_color":"#84CE84","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"dm262\",\"text\":\"Your reads will contain sequencing adapters which require trimming. Examination of read quality has shown us that read ends, both 5` and 3`, are of low quality. Trimming additional sequence from read ends has the advantage of raising the average read quality, preserving as much of our read dataset as possible. Additionally, your fastq file may contain ONT DNA control strand reads which need to be identified and removed.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318720,"number":"5","cases":[],"critical":null},{"id":1318748,"guid":"75AEFE77743411ECBCC40A58A9FEAC02","previous_id":1318747,"previous_guid":"75AEDE5D743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eRead trimming and preliminary filtering\u003c/p\u003e","section_color":"#84CE84","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"frg7p\",\"text\":\"After read trimming, and in the same command queue, we remove all low quality reads and reads less than 1 Kbp in size.  \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"12h4k\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"aqpgt\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Read trimming and preliminary filtering\",\"description\":null,\"guid\":\"68023DB0F4D911EB9E21AFF8AFFFF59C\",\"id\":9910,\"name\":\"zcat reads.fastq.gz |\\n    /path to Nano Pack/NanoLyse -r /path to DNA control strand/DNA_CS.fasta | \\\\\\n    /path to Nano Pack/NanoFilt --headcrop 200 --tailcrop 200 | \\\\\\n    /path to Nano Pack/NanoFilt -q 7 -l 1000 | \\\\\\n    gzip \\u003e preliminary-filter.fastq.gz\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318721,"number":"6","cases":[],"critical":null},{"id":1318749,"guid":"75AF1FD4743411ECBCC40A58A9FEAC02","previous_id":1318748,"previous_guid":"75AEFE77743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eGenome size estimate\u003c/p\u003e","section_color":"#FFED92","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"er6u\",\"text\":\"We next need an estimate of genome size so that read coverage can be calculated. If the genome size for your species or a closely related species is known, use this. If genome size is not known you will need to estimate your genome size using either the assembly method or Genome Scope.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318722,"number":"7","cases":[],"critical":null},{"id":1318750,"guid":"75AF404E743411ECBCC40A58A9FEAC02","previous_id":1318749,"previous_guid":"75AF1FD4743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eGenome size estimate: Assembly method\u003c/p\u003e","section_color":"#EA9F6C","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"1c53c\",\"text\":\"Here we use a quick assembly method on a subset of our read data to assemble and get a genome size estimate. Randomly sample a subset (it is hard to guess how much of your dataset to use, we like to use 50% if sequencing was very successful or 75% if sequencing was less successful) of your read dataset and assemble with Flye (our preference) or Miniasm.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"7u0ck\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"dh9iv\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"bvhge\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":1,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"a04v\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"37hdr\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":2,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"99fa3\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Randomly sample 50% of reads\",\"description\":null,\"guid\":\"EA1BCB30F4DA11EB9E21AFF8AFFFF59C\",\"id\":9911,\"name\":\"seqtk sample -s10 preliminary-filter.fastq.gz $(echo $(zgrep '^\\u003e' preliminary-filter.fastq.gz |wc -l)/2 | bc) | gzip \\u003e subset.fastq.gz\",\"os_name\":null,\"os_version\":null}},\"1\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Randomly sample 75% of reads\",\"description\":null,\"guid\":\"F1A9D860F4DA11EB9E21AFF8AFFFF59C\",\"id\":9912,\"name\":\"seqtk sample -s10 preliminary-filter.fastq.gz $(echo $(zgrep '^\\u003e' preliminary-filter.fastq.gz |wc -l)*0.75 | bc) | gzip \\u003e subset.fastq.gz\",\"os_name\":null,\"os_version\":null}},\"2\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Assemble subset of reads with Flye\",\"description\":null,\"guid\":\"21B38380F4DB11EB9E21AFF8AFFFF59C\",\"id\":9913,\"name\":\"threads=XX\\n\\npath to flye/flye --nano-raw subset.fastq.gz --out-dir /path to save assembly to/ --threads $threads\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318723,"number":"8","cases":[],"critical":null},{"id":1318751,"guid":"75AF6507743411ECBCC40A58A9FEAC02","previous_id":1318750,"previous_guid":"75AF404E743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eGenome size estimate: Assembly method\u003c/p\u003e","section_color":"#EA9F6C","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"7abfr\",\"text\":\"You wont be able to get a good estimate of your genome size until you remove any contaminate contigs and purge haplotigs from your assembly.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"6gpfh\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"21opd\",\"text\":\"To filter contamination see step 16.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"5q2so\",\"text\":\"To purge haplotigs see step 17.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318724,"number":"9","cases":[],"critical":null},{"id":1318752,"guid":"75AF868D743411ECBCC40A58A9FEAC02","previous_id":1318751,"previous_guid":"75AF6507743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eGenome size estimate: Genome Scope (K-mer)\u003c/p\u003e","section_color":"#E57785","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"8s09j\",\"text\":\"If you have access to high accuracy reads (eg. illumina, or HiFi) you can use the k-mer based genome size estimator Genome Scope 2.0. Polishing reads may be used here but may fail if read coverage is insufficient. Additionally, this method will give an estimated ploidy. \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"f4c0r\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"9lms1\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"81fih\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Genome Scope 2.0\",\"description\":null,\"guid\":\"663C875071A811EC9C9C8956590EA71B\",\"id\":9914,\"name\":\"threads=XXX\\n\\njellyfish count -C -m 21 -s 1000000000 -t $threads accurate-reads.fastq.gz -o reads.jf\\njellyfish histo -t $threads reads.jf \\u003e reads.histo\\ngenomescope.R -i reads.histo -o / path to output/ -k 21\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318725,"number":"10","cases":[],"critical":null},{"id":1318753,"guid":"75AFA80C743411ECBCC40A58A9FEAC02","previous_id":1318752,"previous_guid":"75AF868D743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eCoverage specific filtering\u003c/p\u003e","section_color":"#EA94FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"3jfc8\",\"text\":\"Now that we have an estimated genome size we can calculate our estimated coverage and perform additional read filtering if our read dataset has coverage in excess of 60x. More reads, higher coverage, can be used if you have a lot of compute time. More coverage will assemble a better genome, but the effects of increased coverage plateau around ~80x. If using a lot of coverage (\\u003e60x) assembly settings can be tweaked to keep the best reads after read correction.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"a0ldm\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"a9jiq\",\"text\":\" \",\"type\":\"align-center\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"5ihss\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"tex_formula\",\"mutability\":\"\",\"data\":{\"formula\":\"coverage = \\\\frac{total\\\\ number\\\\ of\\\\ bases\\\\ in\\\\ read\\\\ set}{genome\\\\ size}\",\"guid\":\"B60080B0F4E011EB9E21AFF8AFFFF59C\",\"id\":0}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318726,"number":"11","cases":[],"critical":null},{"id":1318754,"guid":"75AFC8B1743411ECBCC40A58A9FEAC02","previous_id":1318753,"previous_guid":"75AFA80C743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eCoverage specific filtering\u003c/p\u003e","section_color":"#EA94FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"4melk\",\"text\":\"Additional read filtering occurs by two metrics, average read quality scores and read length. It can be hard to find the perfect intersection of these two variables, we tend to filter more on length than on quality so as to keep very long reads within our dataset. Change the length and quality values to suit your dataset. \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"9rdri\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"7eq32\",\"text\":\"Removing more reads here will result in faster read correction and trimming in Canu. But it may be preferable to input a larger dataset into Canu and use Canu's \\\"corOutCoverage\\\" parameter to reduce data after read correction. When coverage is greatly in excess we perform additional filtering to ~60-80x and use Canu's corOutCoverage parameter to further reduce coverage to ~30-50x, depending on minimum read length.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"cud3g\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"2hvq3\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"ej3v9\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":1,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"4pm4o\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"71dk7\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":2,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"fmttf\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Length only filtering\",\"description\":null,\"guid\":\"E6A26670F4DB11EB9E21AFF8AFFFF59C\",\"id\":9915,\"name\":\"gne-file.sh preliminary-filter.fastq.gz\\nfor len in 2000 5000 10000 20000\\ndo\\n    awk -v L=$len '{if($2 \\u003e= L){print $1}}' preliminary-filter.genome \\u003e use.lst\\n    seqtk subseq preliminary-filter.fastq.gz use.lst | gzip \\u003e ${len}_final.fastq.gz\\n    gne-file.sh ${len}_final.fastq.gz\\ndone\",\"os_name\":null,\"os_version\":null}},\"1\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Quality only filter\",\"description\":null,\"guid\":\"F8DF48D0F4DB11EB9E21AFF8AFFFF59C\",\"id\":9916,\"name\":\"for qual in 8 9 10\\ndo\\n    zcat all.fasta.gz | /path to Nano Pack/NanoFilt -q $qual | gzip \\u003e q${qual}.fastq.gz\\n    gne-file.sh q${qual}.fastq.gz\\ndone\",\"os_name\":null,\"os_version\":null}},\"2\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Filter on quality and length\",\"description\":null,\"guid\":\"1D8C2B80F4DC11EB9E21AFF8AFFFF59C\",\"id\":9917,\"name\":\"for qual in 8 9 10\\ndo\\n    zcat all.fasta.gz | /home/801/sf3809/.local/bin/NanoFilt -q $qual | gzip \\u003e q${qual}.fastq.gz\\n    gne-file.sh q${qual}.fastq.gz\\n    for len in 2000 5000 10000 20000\\n    do\\n        awk -v L=$len '{if($2 \\u003e= L){print $1}}' q${qual}.genome \\u003e use.lst\\n        seqtk subseq q${qual}.fastq.gz use.lst | gzip \\u003e q${qual}-${len}_final.fastq.gz\\n        [ -e q${qual}-${len}_final.fastq.gz ] \\u0026\\u0026 rm q${qual}-${len}_final.fastq.gz || gne-file.sh q${qual}-${len}_final.fastq.gz\\n    done\\ndone\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318727,"number":"12","cases":[],"critical":null},{"id":1318755,"guid":"75AFF1BC743411ECBCC40A58A9FEAC02","previous_id":1318754,"previous_guid":"75AFC8B1743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eCoverage specific filtering\u003c/p\u003e","section_color":"#EA94FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"5m1uc\",\"text\":\"Having filtered your read dataset we now need to find which filtered fastq to use. Using the genome file created for each fastq, we first calculate the total amount of sequence within each dataset and finally calculate the estimated coverage. You will need to determine and pick the dataset with the most suitable coverage.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"61tdq\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"3svk2\",\"text\":\"Successful assembly will result in the creation of ${label}.contigs.fasta\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Calculate coverage for all filtered datasets\",\"description\":null,\"guid\":\"39FB11F0F4DC11EB9E21AFF8AFFFF59C\",\"id\":9918,\"name\":\"genomeSize=XXX\\nfor gne in *.genome\\ndo\\n    filt=$(basename $gne .genome)\\n    echo $filt $(echo $(cut -f2 $gne | paste -s -d+ | bc)/${genomeSize} | bc)\\ndone\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318728,"number":"13","cases":[],"critical":null},{"id":1318756,"guid":"75B01520743411ECBCC40A58A9FEAC02","previous_id":1318755,"previous_guid":"75AFF1BC743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eAssemble genome\u003c/p\u003e","section_color":"#A492FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"90crn\",\"text\":\"Many of the parameters and methods of getting Canu to work are workspace and dataset dependent. We will detail the parameters that we have found to impact assembly the most, or have been necessary to get Canu to assemble our genomes in a timely manner.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"5ntcc\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"bkrh1\",\"text\":\"Canu’s read the docs website contains a lot of good information on assembly.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"4f8t6\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"6gr9s\",\"text\":\"corOutCoverage - how much coverage to keep after read correction. Canu will estimate corrected read size before correcting and only correct the longest X coverage of reads. A larger value can give a better assembly, but will also consume many more computer resources. \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[{\"style\":\"bold\",\"offset\":0,\"length\":14}],\"entityRanges\":[],\"data\":[]},{\"key\":\"6m99h\",\"text\":\"Another consideration when setting this parameter is read length. If your read set is very long (min size \\u003e\\u003e 20kb) assembly can be very slow, as such a reduced amount of corrected reads may be necessary.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"bnsqp\",\"text\":\"This should be tuned to suit your compute resources. The maximum recommended is 80, with 30-60 producing very good results.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"a4ua4\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"4v1br\",\"text\":\"correctedErrorRate - The allowable percent error rate between corrected reads (eg. 0.12 = 12%). Meta setting for many other assembly stages. The default is 0.144 for ONT reads, if you have excessive input coverage reduce this value. If starting with low coverage leave this at defaults. If using high accuracy ONT reads (basecalled with guppy 5+) Canu docs recommend to set at 0.105.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[{\"style\":\"bold\",\"offset\":0,\"length\":18}],\"entityRanges\":[],\"data\":[]},{\"key\":\"e8g70\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"34vrk\",\"text\":\"corMaxEvidenceErate - Only correct reads that have this fraction or lower fraction of errors, determined by overlapping reads. We have found this setting to be necessary for many plant (highly repetitive) genome assemblies which fail to assemble as jobs exceed our maximum allowed run time. We leave this set at 0.15 for all assemblies.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[{\"style\":\"bold\",\"offset\":0,\"length\":19}],\"entityRanges\":[],\"data\":[]},{\"key\":\"5ee1o\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"cs2jf\",\"text\":\"batOptions - The settings used here are described within the canu documents as “avoid collapsing the genome”. We have found that assemblies made with these settings have a broader distribution of contigs lengths, ie. more short and more long contigs, and as the majority of small contigs are removed during haplotype purging, these parameters give a more contiguous final genome. We leave this as “batOptions=-dg 3 -db 3 -dr 1 -ca 500 -cp 50\\\" for all assemblies. The small purged contigs are regions of the parental haplotype in the alternative parent.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[{\"style\":\"bold\",\"offset\":0,\"length\":10}],\"entityRanges\":[],\"data\":[]},{\"key\":\"a37r2\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"dh76l\",\"text\":\"fast - Use MHAP (a fast but less accurate aligner) for read correction, trimming, and assembly (default: correction = MHAP, trimming and assembly = ovl). With some plant genomes read overlapping would fail to complete in a timely manner, as such we use fast (MHAP) for all overlapping to avoid wasting large amounts of our compute allocation.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[{\"style\":\"bold\",\"offset\":0,\"length\":4}],\"entityRanges\":[],\"data\":[]},{\"key\":\"7opph\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"84mtc\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Assemble genome with Canu\",\"description\":null,\"guid\":\"19FD77C0F4E211EB9E21AFF8AFFFF59C\",\"id\":9919,\"name\":\"label=example\\nsaveLocation=\\\"/location to save to/\\\"\\nreads=\\\"/location of reads/example.fastq.gz\\\"\\nstageDirectory=\\\"/path to fast disk space/\\\"\\ngenomeSize=500m\\ncorrectCoverage=60\\ncorrectedErrorRate=0.105\\ncorMaxEvidenceErate=0.15\\n\\n/path to canu/canu \\\\\\n        -p $label \\\\\\n        -d ${saveLocation}/canu_${label} \\\\\\n        -nanopore $reads \\\\\\n        genomeSize=${genomeSize} \\\\\\n        stageDirectory=${stageDirectory} \\\\\\n        corOutCoverage=${correctCoverage} \\\\\\n        \\\"batOptions=-dg 3 -db 3 -dr 1 -ca 500 -cp 50\\\" \\\\\\n        correctedErrorRate=${correctedErrorRate} \\\\\\n        corMaxEvidenceErate=${corMaxEvidenceErate} \\\\\\n        -fast\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318729,"number":"14","cases":[],"critical":null},{"id":1318757,"guid":"75B04727743411ECBCC40A58A9FEAC02","previous_id":1318756,"previous_guid":"75B01520743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eAssemble genome\u003c/p\u003e","section_color":"#A492FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"q6th\",\"text\":\"Successful assembly will result in the creation of ${label}.contigs.fasta\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318730,"number":"15","cases":[],"critical":null},{"id":1318758,"guid":"75B066B4743411ECBCC40A58A9FEAC02","previous_id":1318757,"previous_guid":"75B04727743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eContamination filter\u003c/p\u003e","section_color":"#94EBFF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"9h0iu\",\"text\":\"DNA extraction likely resulted in the collection and sequencing of DNA from contaminate sources (eg. fungus living on leaf surfaces). If these sequences were assembled they will be present within your assembly. Contamination sequences are taxonomically identified with blast and blob tools, and removed using seqtk and bash commands. \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"ce3ei\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"5fjvv\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"4aodt\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":1,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"24s04\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"c0cmp\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":2,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"bik2u\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"60d40\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":3,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"bs6ot\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"bfvvj\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":4,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"6ftka\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Setup\",\"description\":null,\"guid\":\"10790B40F50211EB9E21AFF8AFFFF59C\",\"id\":9920,\"name\":\"genome=/path to assembly/${label}.contigs.fasta or unitigs.fasta\\nreads=\\\"/location of reads/example.fastq.gz\\\"\\ncpus=\\\"XX\\\"\\nmemory=\\\"XXG\\\"\\nncbiDB=\\\"/path ot ncbi db/nt\\\"\",\"os_name\":null,\"os_version\":null}},\"1\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Align reads to genome\",\"description\":null,\"guid\":\"1E0B5150F50211EB9E21AFF8AFFFF59C\",\"id\":9921,\"name\":\"minimap2 -t $cpus -ax map-ont $genome $reads | \\\\\\n    samtools sort -m $memory -@ $cpus \\u003e sorted_mapped_reads.bam\\nsamtools index -@ $cpus sorted_mapped_reads.bam\",\"os_name\":null,\"os_version\":null}},\"2\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Blast contigs/unitigs\",\"description\":null,\"guid\":\"36AE1490F50211EB9E21AFF8AFFFF59C\",\"id\":9922,\"name\":\"blastn -query $genome -db $ncbiDB -outfmt \\\"6 qseqid staxids bitscore std\\\" -max_target_seqs 10 -max_hsps 1 -evalue 1e-25 -out ${label}.out\",\"os_name\":null,\"os_version\":null}},\"3\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Blobtools - id sequence taxonomy\",\"description\":null,\"guid\":\"4F495DC0F50211EB9E21AFF8AFFFF59C\",\"id\":9923,\"name\":\"blobtools create -i $genome -b sorted_mapped_reads.bam -t ${label}.out -o contamination\\nblobtools plot -i contamination.blobDB.json -o blobP\\nblobtools view -i contamination.blobDB.json -o blobV\",\"os_name\":null,\"os_version\":null}},\"4\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Create contamination filtered fasta\",\"description\":null,\"guid\":\"776A5890F50211EB9E21AFF8AFFFF59C\",\"id\":9924,\"name\":\"grep -v '^#' blobV.contamination.blobDB.table.txt | grep -vE 'Bacteroidetes|Ascomycota|Proteobacteria|Arthropoda' | awk '{print \\\\$1}' \\u003e keep.lst\\ngrep -v '^#' blobV.contamination.blobDB.table.txt | grep -E 'Bacteroidetes|Ascomycota|Proteobacteria|Arthropoda'  | awk '{print \\\\$1}' \\u003e contaminant.lst\\nseqtk subseq $genome keep.lst \\u003e keep.fasta\\nseqtk subseq $genome contaminant.lst \\u003e contamination.fasta\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318731,"number":"16","cases":[],"critical":null},{"id":1318759,"guid":"75B09087743411ECBCC40A58A9FEAC02","previous_id":1318758,"previous_guid":"75B066B4743411ECBCC40A58A9FEAC02","section":"\u003cp\u003ePurge haplotigs\u003c/p\u003e","section_color":"#84CE84","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"etm3h\",\"text\":\"When regions of the parental haplotypes highly differ the assembler will produce two sequences that represent the same genetic region. As we are building a pseudo-haploid genome we need to identify the sequences that make up these doubly represented regions and remove one. Haplotig removal is performed to improve genome contiguity, as such the longest sequence is kept within the assembly. As this process aligns assembly reads to our genome we can also identify plasmid sequences within our assembly as they will have a very high or very low read coverage.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"439n0\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"1ip50\",\"text\":\"Note: read alignment was already performed during contamination removal, as such we skip here and use the existing bam file.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"4jb78\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"8p9d6\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"2eu31\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":1,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"4gqpt\",\"text\":\"View read histogram (sorted_mapped_reads.bam.histogram.png) and pick cutoffs\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"a63bb\",\"text\":\"for more information see https://bitbucket.org/mroachawri/purge_haplotigs/src/master/\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":2,\"offset\":25,\"length\":60}],\"data\":[]},{\"key\":\"5f4ks\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":3,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"dejr5\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Setup\",\"description\":null,\"guid\":\"B3CEDB30F50211EB9E21AFF8AFFFF59C\",\"id\":9925,\"name\":\"bam=\\\"/path to contamination filtering/sorted_mapped_reads.bam\\\"\\ngenome=\\\"/path to contamination filtering/keep.fasta\\\"\\ncpus=XX\",\"os_name\":null,\"os_version\":null}},\"1\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Build read histogram\",\"description\":null,\"guid\":\"C7E2C780F50211EB9E21AFF8AFFFF59C\",\"id\":9926,\"name\":\"purge_haplotigs hist -b $bam -g $genome -t $cpus\",\"os_name\":null,\"os_version\":null}},\"2\":{\"type\":\"link\",\"mutability\":\"\",\"data\":{\"guid\":\"DB3CB50EF50211EBAB810A58A9FEAC02\",\"url\":\"https://bitbucket.org/mroachawri/purge_haplotigs/src/master\"}},\"3\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Purge genome\",\"description\":null,\"guid\":\"F8331890F50211EB9E21AFF8AFFFF59C\",\"id\":9927,\"name\":\"lower=XX\\nmedium=XX\\nhigh=XX\\n\\npurge_haplotigs contigcov -i sorted_mapped_reads.bam.gencov -l $lower -m $medium -h $high \\npurge_haplotigs purge -g $genome -c coverage_stats.csv -b $bam -d -t $cpus\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318732,"number":"17","cases":[],"critical":null},{"id":1318760,"guid":"75B0B6C6743411ECBCC40A58A9FEAC02","previous_id":1318759,"previous_guid":"75B09087743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eLong read polish\u003c/p\u003e","section_color":"#FFED92","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"bhebn\",\"text\":\"Despite Canu’s read correction stage, polishing of your assembly with assembly read fastq has been shown to improve base accuracy. Improvement was assessed with BUSCO scores. Long read polishing is performed with minimap2 and Racon. We typically perform two rounds of polishing in this step. \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"18ven\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"62nok\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Racon polish\",\"description\":null,\"guid\":\"4C839190F50311EB9E21AFF8AFFFF59C\",\"id\":9928,\"name\":\"genome=\\\"/path to contamination filtering/curated.fasta\\\"\\nreads=\\\"/location of reads/example.fastq.gz\\\"\\ncpus=\\\"XX\\\"\\nrounds=2\\n\\nfor ((i=1; i\\u003c=${rounds};i++))\\ndo\\n    # map long reads with minimap2\\n    minimap2 -t $cpus -ax map-ont ${genome} ${reads} \\u003e mapped_reads.sam\\n    # run racon\\n    racon -t $cpus -u ${reads} mapped_reads.sam ${genome} \\u003e racon-${i}\\n    genome=racon-${i}.fasta\\ndone\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318733,"number":"18","cases":[],"critical":null},{"id":1318761,"guid":"75B0D947743411ECBCC40A58A9FEAC02","previous_id":1318760,"previous_guid":"75B0B6C6743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eShort read polishing - NextPolish\u003c/p\u003e","section_color":"#EA9F6C","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"3hl9s\",\"text\":\"The first of our short read polishers is Next Polish, it works with bwa mem. For this polishing step we use 20-25x coverage of illumina data. There are a number of different ways of running Next polish, which one you use will depend on your compute environment. We have found success within our compute environment by running the python3 script nextpolish1.py. \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"2k7vj\",\"text\":\"We typically perform two rounds of polishing in this step.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"23are\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"e3usn\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Nextpolish polish\",\"description\":null,\"guid\":\"8850DD40F50311EB9E21AFF8AFFFF59C\",\"id\":9929,\"name\":\"reads=\\\"/location of reads/example.fastq.gz\\\"\\ngenome=\\\"/path to long read polish/racon-2.fasta\\\"\\nrounds=2\\ncpus=XX\\nmemory=XXg\\n\\nfor ((i=1; i\\u003c=${rounds};i++))\\ndo\\n#step 1\\n    #index the genome and do alignment\\n    bwa index $genome\\n    bwa mem -t $cpus -p $genome $reads \\\\\\n        | samtools view -@ $cpus -F 0x4 -b - \\\\\\n        | samtools fixmate -m -@ $cpus  - - \\\\\\n        | samtools sort -m $memory -@ $cpus - \\\\\\n        | samtools markdup -@ $cpus -r - sorted.bam\\n    #index bam and genome\\n    samtools index -@ $cpus sorted.bam\\n    samtools faidx $genome\\n    #polish genome\\n    python nextpolish1.py -g $genome -t 1 -p $cpus -s sorted.bam \\u003etmp~${i}.fasta\\n#step 2\\n    #index the genome and do alignment\\n    bwa index tmp~${i}.fasta\\n    bwa mem -t $cpus -p tmp~${i}.fasta ${readFile} \\\\\\n        | samtools view -@ $cpus -F 0x4 -b - \\\\\\n        | samtools fixmate -m -@ $cpus  - - \\\\\\n        | samtools sort -m $memory -@ $cpus - \\\\\\n        | samtools markdup -@ $cpus -r - sorted.bam\\n    #index bam and genome\\n    samtools index -@ $cpus sorted.bam\\n    samtools faidx tmp~${i}.fasta\\n    #polish genome\\n    python nextpolish1.py -g tmp~${i}.fasta -t 2 -p $cpus -s sorted.bam \\u003e nextPolish~${i}.fasta\\n\\n     genome=nextPolish~${i}.fasta\\ndone\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318734,"number":"19","cases":[],"critical":null},{"id":1318762,"guid":"75B0FCCC743411ECBCC40A58A9FEAC02","previous_id":1318761,"previous_guid":"75B0D947743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eShort read polishing - Hapo-G\u003c/p\u003e","section_color":"#E57785","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"co3g0\",\"text\":\"In addition to Nextpolish we run a second short read polisher, Hapo-G. Results obtained within the Hapo-G paper indicate that polishing first with Next Polish and then Hapo-G obtained the most accurate genome.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"7huh7\",\"text\":\"We typically perform three rounds of polishing in this step.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"daghp\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"d521\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Haop-G polish\",\"description\":null,\"guid\":\"BF402090F50311EB9E21AFF8AFFFF59C\",\"id\":9930,\"name\":\"reads=\\\"/location of reads/example.fastq.gz\\\"\\ngenome=\\\"/path to Next Polish/racon-2.fasta\\\"\\nrounds=3\\ncpus=XX\\nmemory=XXg\\n\\nzcat $genome | sed -e 's/_.*//g' \\u003e hapog-0.fasta\\ngenome=hapog-0.fasta\\n\\nfor ((i=1; i\\u003c=${rounds};i++))\\ndo\\n    #index the genome and do alignment\\n    bwa index $genome\\n    bwa mem -t $cpus -p $genome $reads \\\\\\n        | samtools sort -m $memory -@ $cpus \\u003e sorted.bam\\n    #index bam and genome\\n    samtools index -@ $cpus sorted.bam\\n\\n    #polish\\n    python3 hapog.py --genome $genome -b sorted.bam -o ${i} -t $cpus -u\\n\\n    genome=${i}/hapog_results/hapog.fasta\\ndone\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318735,"number":"20","cases":[],"critical":null},{"id":1318763,"guid":"75B12122743411ECBCC40A58A9FEAC02","previous_id":1318762,"previous_guid":"75B0FCCC743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eFilter small contigs\u003c/p\u003e","section_color":"#EA94FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"ch47g\",\"text\":\"Small contigs contain little useful genetic information and are filtered from our assemblies. We typically remove any sequence less than 1 Kbp in length. \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"2v2d5\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"6geg1\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Filter small contigs\",\"description\":null,\"guid\":\"0A1B55D0F50411EB9E21AFF8AFFFF59C\",\"id\":9931,\"name\":\"bioawk -c fastx 'length($seq) \\u003e 1000{print \\\"\\u003e\\\" $name \\\"\\\\n\\\" $seq}' hapog.fasta \\u003e sizeFiltered.fasta\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318736,"number":"21","cases":[],"critical":null},{"id":1318764,"guid":"75B14387743411ECBCC40A58A9FEAC02","previous_id":1318763,"previous_guid":"75B12122743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eFilter plasmid contigs\u003c/p\u003e","section_color":"#A492FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"8rtt9\",\"text\":\"Despite filtering for plasmid sequences during haplotig purging some plasmid sequences may still remain within the assembly. Here we use MUMmer to find alignments between our genome and known plasmid sequences. The sequences we screen our genome with are obtained from a public repository such as the NCBI. If no plasmid sequences exist for your species, find the closest available relative and download chloroplast and mitochondria sequences.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"esf3f\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"4tn9v\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"MUMmer align and dotplot plasmid seqeunces\",\"description\":null,\"guid\":\"4C71C1D0F50411EB9E21AFF8AFFFF59C\",\"id\":9932,\"name\":\"genome=”/path to genome/sizeFiltered.fasta”\\nfor plasmid in /path_to_plasmid/XX.fasta /path_to_plasmid/YY.fasta\\ndo\\n    tmp=$(basename $plasmid)\\n    name=${tmp%.fasta*}\\n\\n    mkdir $name\\n    cd $name\\n\\n    nucmer -t 1 $genome $plasmid\\n    delta-filter -1 -m -i 90 -l 100 out.delta \\u003e out.1delta\\n\\n    for tig in `grep '^\\u003e' out.1delta | cut -f1 -d' ' | sort | uniq | sed -e 's/\\u003e//g'`\\n    do\\n        echo $tig \\u003e tmp.lst\\n        seqtk subseq $genome tmp.lst \\u003e tmp.fasta\\n        nucmer -t 1 tmp.fasta $plasmid -p $tig\\n        delta-filter -1 ${tig}.delta \\u003e out.1delta\\n        mummerplot --fat --png --large out.1delta -p ${tig}\\n    done\\n    rm tmp.lst tmp.fasta\\n    cd ../..\\ndone\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318737,"number":"22","cases":[],"critical":null},{"id":1318765,"guid":"75B16783743411ECBCC40A58A9FEAC02","previous_id":1318764,"previous_guid":"75B14387743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eFilter plasmid contigs\u003c/p\u003e","section_color":"#A492FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"7eocu\",\"text\":\"On completion of MUMmer alignments you will find a number of png files within subdirectories named after your plasmid sequences. These images contain a dot plot showing the alignment between all sequences within your genome that are highly aligned to the plasmid. Each image needs to be reviewed and a decision made on whether the sequence originates within the plasmid or not. If you decide that the sequence is plasmid, record its name in remove.lst.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318738,"number":"23","cases":[],"critical":null},{"id":1318766,"guid":"75B18713743411ECBCC40A58A9FEAC02","previous_id":1318765,"previous_guid":"75B16783743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eFilter plasmid contigs\u003c/p\u003e","section_color":"#A492FF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"3g7m4\",\"text\":\"Once you have decided which sequences you wish to remove the following script will perform the sequence removal. \",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"42ejr\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"key\":0,\"offset\":0,\"length\":1}],\"data\":[]},{\"key\":\"f6h46\",\"text\":\"\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{\"0\":{\"type\":\"command\",\"mutability\":\"\",\"data\":{\"can_edit\":true,\"command\":null,\"command_name\":\"Filter plasmid sequences\",\"description\":null,\"guid\":\"93BD67B0F50411EB9E21AFF8AFFFF59C\",\"id\":9933,\"name\":\"genome=”/path to genome/sizeFiltered.fasta”\\n\\nbioawk -c fastx '{print $name}' $genome \\u003e all.lst\\ngrep -vwf remove.lst \\u003c all.lst \\u003e keep.lst\\nseqtk subseq $genome keep.lst \\u003e plasmid-filtered.fasta\",\"os_name\":null,\"os_version\":null}}}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318739,"number":"24","cases":[],"critical":null},{"id":1318767,"guid":"75B1A9AD743411ECBCC40A58A9FEAC02","previous_id":1318766,"previous_guid":"75B18713743411ECBCC40A58A9FEAC02","section":"\u003cp\u003eGenome complete\u003c/p\u003e","section_color":"#94EBFF","section_duration":0,"is_substep":false,"step":"{\"blocks\":[{\"key\":\"b60r7\",\"text\":\"Your genome is now complete and ready for use. If possible it is highly recommended to scaffold your genome using Hi-C or if Hi-C is not available with synteny information obtained from a closely related species. If you wish to scaffold please see the section on scaffolding. Also, see the section on assembly quality to help with assessing your assembly success.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]}],\"entityMap\":{}}","data":null,"protocol_id":56861,"case_id":0,"critical_ids":"","duration":0,"original_id":1318740,"number":"25","cases":[],"critical":null}],"template_id":5,"title":"Long-read plant genome assembly and annotation: assembly","title_html":"\u003cp\u003eLong-read plant genome assembly and annotation: assembly\u003c/p\u003e","type_id":1,"units":[{"id":1,"type_id":3,"name":"µL","can_manage":0},{"id":2,"type_id":3,"name":"mL","can_manage":0},{"id":3,"type_id":3,"name":"L","can_manage":0},{"id":4,"type_id":3,"name":"µg","can_manage":0},{"id":5,"type_id":3,"name":"mg","can_manage":0},{"id":6,"type_id":3,"name":"g","can_manage":0},{"id":7,"type_id":3,"name":"kg","can_manage":0},{"id":8,"type_id":3,"name":"ng","can_manage":0},{"id":9,"type_id":3,"name":"Hz","can_manage":0},{"id":10,"type_id":24,"name":"°C","can_manage":0},{"id":11,"type_id":24,"name":"°К","can_manage":0},{"id":12,"type_id":24,"name":"°F","can_manage":0},{"id":13,"type_id":25,"name":"Mass Percent","can_manage":0},{"id":14,"type_id":25,"name":"% volume","can_manage":0},{"id":15,"type_id":25,"name":"Mass / % volume","can_manage":0},{"id":16,"type_id":25,"name":"Parts per Million (PPM)","can_manage":0},{"id":17,"type_id":25,"name":"Parts per Billion (PPB)","can_manage":0},{"id":18,"type_id":25,"name":"Parts per Trillion (PPT)","can_manage":0},{"id":19,"type_id":25,"name":"Mole Fraction","can_manage":0},{"id":20,"type_id":25,"name":"Mole Percent","can_manage":0},{"id":21,"type_id":25,"name":"Molarity (M)","can_manage":0},{"id":22,"type_id":25,"name":"Molarity (m)","can_manage":0},{"id":23,"type_id":25,"name":"Genome copies per ml","can_manage":0},{"id":24,"type_id":3,"name":"μV","can_manage":0},{"id":25,"type_id":3,"name":"ms","can_manage":0},{"id":26,"type_id":3,"name":"pg","can_manage":0},{"id":27,"type_id":25,"name":"Molarity dilutions","can_manage":0},{"id":28,"type_id":25,"name":"millimolar (mM)","can_manage":0},{"id":29,"type_id":25,"name":"micromolar (µM)","can_manage":0},{"id":30,"type_id":25,"name":"nanomolar (nM)","can_manage":0},{"id":31,"type_id":25,"name":"picomolar (pM)","can_manage":0},{"id":32,"type_id":24,"name":"Room temperature","can_manage":0},{"id":33,"type_id":30,"name":"rpm","can_manage":0},{"id":34,"type_id":30,"name":"x g","can_manage":0},{"id":165,"type_id":24,"name":"On ice","can_manage":0},{"id":200,"type_id":32,"name":"cm","can_manage":0},{"id":201,"type_id":32,"name":"mm","can_manage":0},{"id":202,"type_id":32,"name":"µm","can_manage":0},{"id":203,"type_id":32,"name":"nm","can_manage":0},{"id":204,"type_id":25,"name":"mg/mL","can_manage":0},{"id":205,"type_id":25,"name":"µg/µL","can_manage":0},{"id":206,"type_id":25,"name":"% (v/v)","can_manage":0},{"id":1324,"type_id":30,"name":"rcf","can_manage":0},{"id":1359,"type_id":35,"name":"Bar","can_manage":0},{"id":1360,"type_id":35,"name":"Pa","can_manage":0}],"uri":"long-read-plant-genome-assembly-and-annotation-ass-b3r5qm86","url":"https://www.protocols.io/view/long-read-plant-genome-assembly-and-annotation-ass-b3r5qm86","version_class":56861,"version_data":{"id":0,"code":"b3r5qm86","version_class":56861,"parent_id":null,"parent_uri":null,"is_same_owner":false,"is_parent_public":false,"has_pending_merge_request":false,"has_approved_merge_request":false,"merge_request":null},"version_id":0,"version_uri":"long-read-plant-genome-assembly-and-annotation-ass-dm6gpbr1jlzp/v1","versions":[{"id":59658,"title":"Plant assemble - Plant de novo genome assembly: assembly","title_html":"\u003cp\u003ePlant assemble - Plant de novo genome assembly: assembly\u003c/p\u003e","image":{"source":"https://s3.amazonaws.com/protocols-files/files/gyn8bmnvf.jpg","webp_source":null,"placeholder":"https://s3.amazonaws.com/protocols-files/files/gyn8bmnvf.jpg","webp_placeholder":null},"doi":"dx.doi.org/10.17504/protocols.io.dm6gpbr1jlzp/v2","uri":"plant-assemble-plant-de-novo-genome-assembly-assem-b6hirb4e","published_on":1647906379,"modified_on":1647906379,"version_class":56861,"version_id":1,"version_code":"b6hirb4e","version_uri":"plant-assemble-plant-de-novo-genome-assembly-assem-dm6gpbr1jlzp/v2","created_on":1647825520,"categories":null,"creator":{"name":"Scott Ferguson","affiliation":"Australian National University","affiliation_url":"scott.ferguson@anu.edu.au","username":"scott-ferguson","link":"","image":{"source":"/img/avatars/017.png","placeholder":"/img/avatars/017.png","webp_source":""}},"stats":{"number_of_comments":0,"last_comment_time":0}}],"warning":""}