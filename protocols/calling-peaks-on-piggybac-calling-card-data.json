{"id":32791,"title":"Calling Peaks on piggyBac Calling Card Data","title_html":"<p>Calling Peaks on piggyBac Calling Card Data<\/p>","image":{"source":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/b2ca4s6w.png","placeholder":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/b2ca4s6w.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.bb9xir7n","doi_status":2,"uri":"calling-peaks-on-piggybac-calling-card-data-bb9xir7n","type_id":1,"published_on":1583874707,"parent_protocols":[],"parent_collections":[],"cited_protocols":[],"version_id":0,"created_on":1580960764,"categories":null,"creator":{"name":"Arnav Moudgil","affiliation":"Washington University, Saint Louis","affiliations":[{"affiliation":"Washington University, Saint Louis","url":"http:\/\/genetics.wustl.edu\/rmlab\/","is_default":1}],"username":"arnav-moudgil","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg"},"badges":[{"id":3,"image":{"source":"\/img\/badges\/silver.svg","placeholder":"\/img\/badges\/silver.svg"},"name":"Power author!"}],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"journal":null,"journal_name":null,"journal_link":null,"article_citation":null,"public":1,"has_versions":0,"link":null,"total_collections":0,"number_of_steps":26,"authors":[{"name":"Arnav Moudgil","affiliation":"Washington University, Saint Louis","affiliations":[],"username":"arnav-moudgil","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},{"name":"Rob Mitra","affiliation":"Washington University, Saint Louis","affiliations":[],"username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false}],"versions":[],"groups":[{"id":1136,"uri":"calling-cards","title":"Transposon Calling Cards","image":{"source":"https:\/\/www.protocols.io\/img\/group_placeholder.png","placeholder":"https:\/\/www.protocols.io\/img\/group_placeholder.png"},"tech_support":{"email":null,"phone":null,"hide_contact":0,"use_email":0,"url":null},"is_member":1,"request":{"id":1136,"uri":"calling-cards","title":"Transposon Calling Cards","image":{"source":"https:\/\/www.protocols.io\/img\/group_placeholder.png","placeholder":"https:\/\/www.protocols.io\/img\/group_placeholder.png"},"tech_support":{"email":null,"phone":null,"hide_contact":0,"use_email":0,"url":null},"is_member":1,"description":null,"research_interests":null,"website":null,"location":null,"affiliation":null,"status":{"is_visible":true,"access_level":0},"stats":{"files":[],"total_members":0,"total_followers":0,"total_child_groups":0,"total_parent_groups":0,"has_collaborations":0},"user_status":{"is_member":true,"is_confirmed":true,"is_invited":false,"is_owner":true,"is_admin":false,"is_following":false},"join_link":null,"token":null,"owner":{"name":" ","affiliation":null,"affiliations":[],"username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"is_protocol_requested":0,"is_group_requested":0,"is_my":false,"is_request":false,"is_confirmed":1,"is_declined":0,"requester":{"name":" ","affiliation":null,"affiliation_url":null,"username":null,"link":null},"protocol":{"id":0,"title":"Calling Peaks on piggyBac Calling Card Data","title_html":"Calling Peaks on piggyBac Calling Card Data","image":{"source":null,"placeholder":null},"doi":null,"doi_status":0,"uri":"calling-peaks-on-piggybac-calling-card-data-bb9xir7n","type_id":1,"published_on":null,"stats":{"number_of_views":0,"number_of_steps":0,"number_of_bookmarks":0,"number_of_comments":0,"number_of_exports":0,"number_of_runs":0,"number_of_votes":0,"is_voted":0},"parent_protocols":[],"parent_collections":[],"cited_protocols":[]},"created_on":1583874705,"resolve_on":0,"resolved_user":{"name":" ","affiliation":null,"affiliations":[],"username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"shared":false}}],"is_owner":1,"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"can_be_copied":1,"can_remove_fork":1,"fork_id":null,"forks_count":{"private":0,"public":0},"access":{"can_view":1,"can_remove":0,"can_add":0,"can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":1,"can_move":1,"can_move_outside":1,"can_transfer":1,"can_download":1,"is_locked":0},"guid":"2D9E6890489311EA833161FE59E042D2","state_version_id":4869,"steps":[{"id":879258,"guid":"7A994550489A11EA833161FE59E042D2","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"72B174DE92DE427381021A5E9E6F7FBE","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preprocessing"}},{"id":1054724,"guid":"32361B94D65A49A18EE07CD8822FFA13","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Before calling peaks on calling card data, it is useful to create a file listing the location of every TTAA tetramer in the genome. The <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> transposase inserts almost exclusively into this motif. Morever, we use the presence of a TTAA adjacent to a mapped read as an internal quality check when creating CCF files. This section will walk you through how to quickly find all TTAA's in a genome.<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879259,"guid":"AEA98F20489B11EA82FCE1C3EC53666F","previous_id":879258,"previous_guid":"7A994550489A11EA833161FE59E042D2","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"6960C964432B413594D945949A1EDCFF","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preprocessing"}},{"id":1054724,"guid":"09F4623A320540689CA5DA7892A31273","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Compile the kmer.cc program as follows:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">g++ kmer.cc -o kmer<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>The result should be a C++ executable in your directory called <\/span><span style = \"font-weight:bold;\">kmer<\/span><span style = \"font-weight:bold;\">.<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879260,"guid":"5A649260489C11EA82FCE1C3EC53666F","previous_id":879259,"previous_guid":"AEA98F20489B11EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"DA92B2CDC7E04C2EBB4E674FA23996B5","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preprocessing"}},{"id":1054724,"guid":"19769EBE71374A9FA0C528B8C7679959","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">This program takes as input a FASTA file and k-mer and outputs a BED file of all exact matches to that k-mer. Here we use it to find all exact matches to the 4-mer TTAA.<\/div><div class = \"text-block\">Download or copy to your working directory a FASTA file of your genome of interest. Using the latest human genome build as an example:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">.\/kmer hg38.fa TTAA > hg38_TTAA.bed<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">The file hg38_TTAA.bed now lists all TTAA's in hg38.fa.<\/div><\/div>"}},{"id":1054725,"guid":"72D82BF0A41A43299371A29DF93A6FFD","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">It is important that the FASTA file that you use in this step is the same FASTA sequence used for aligning calling card reads. For example, if you mapped to a repeat-masked genome earlier, you should supply a repeat-masked FASTA file here.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879261,"guid":"6D279F40489D11EA82FCE1C3EC53666F","previous_id":879260,"previous_guid":"5A649260489C11EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"4B6D3806DB324AB0ACBB6D0EE64ECD98","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preprocessing"}},{"id":1054724,"guid":"6EBDBABF1EA04F12A678DD782295326D","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">(Optional) More recent builds of the human and mouse genomes contain unplaced contigs and alternate haplotypes. You maybe interested in restricting your analysis to the \"canonical\" chromosomes (e.g. 1-22, X & Y for humans). Here is a simple way to filter only \"canonical\" TTAAs:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">grep -v '_' hg38_TTAA.bed > hg38_TTAA_canon.bed<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">(If you are being nitpicky, this file will include TTAAs on the mitochondrial chromosome, but we have not found this to be a problem for peak calling).<\/div><\/div>"}},{"id":1054725,"guid":"BFEFB61DA2864631B085F4A61A117BBA","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">If you filter only \"canonical\" TTAAs, it is important that you also filter your CCF file so it contains only insertions mapping to \"canonical\" chromosomes. The above command can be used to do so. If you do not do this, you may get \"divide by zero\" errors in subsequent steps.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879262,"guid":"D79E4D50489E11EA82FCE1C3EC53666F","previous_id":879268,"previous_guid":"F93623A048A511EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"F8B119D5D0D74C9ABE71F2828A2BCF11","order_id":1,"type_id":6,"title":"Section","source":{"title":"Bayesian Blocks"}},{"id":1054724,"guid":"450ED8C51DF841EBB88D4C226ECB3473","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>The core of calling peaks in calling card data is Bayesian blocks. This algorithm, originally developed in astrophysics, segments one-dimensional datasets into regions of piecewise-constant density. We use it to initially partition the genome into intervals, where each interval contains a constant rate of <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> insertions. These intervals are referred to as <\/span><span style = \"font-weight:bold;\">blocks<\/span><span>; two adjacent blocks are characterized by different insertion rates and, accordingly, different insertion densities. One attractive reason for using Bayesian blocks is that it can find a mathematically optimal partition of the data into blocks. Peak calling then proceeds by testing each block to see if it contains more insertions than expected by some background model.<\/span><\/div><div class = \"text-block\">This much overview of Bayesian blocks is sufficient to understand peak calling. For more details, we recommend reading the original paper (<\/div><div class = \"text-block\"><a href=\"http:\/\/dx.doi.org\/10.1088\/0004-637X\/764\/2\/167\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">Scargle et al. 2013<\/span><\/a><\/div><div class = \"text-block\">) or this <\/div><div class = \"text-block\"><a href=\"https:\/\/jakevdp.github.io\/blog\/2012\/09\/12\/dynamic-programming-in-python\/\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">blog post by Jake VanderPlas<\/span><\/a><\/div><div class = \"text-block\">.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879263,"guid":"1E99C57048A111EA82FCE1C3EC53666F","previous_id":879262,"previous_guid":"D79E4D50489E11EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"7063DDB2FEAD4DD08F3531B907575128","order_id":1,"type_id":6,"title":"Section","source":{"title":"Bayesian Blocks"}},{"id":1054724,"guid":"80D2479E174D418BAD8B996B1C902825","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">We generate a list of blocks from CCF files, but these files must first be sorted. Here are three ways to sort CCF files, in order of preference:<\/div><div class = \"text-block\">Using bedops:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">sort-bed sample.ccf > sample_sorted.ccf<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Using bedtools:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">bedtools sort -i sample.ccf > sample_sorted.ccf<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Using the standard shell sort command:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">sort -k1V -k2n -k3n sample.ccf > sample_sorted.ccf<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">For the remainder of this protocol, we assume your CCF files are already sorted.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879265,"guid":"E4ED9A2048A211EA82FCE1C3EC53666F","previous_id":879263,"previous_guid":"1E99C57048A111EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"D3DE7A1CEBB049E59C530EB9C55803CA","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling BRD4 Peaks"}},{"id":1054724,"guid":"C28D4C4B40E64857A7BC3AB18AE285EF","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Here we will describe how to call BRD4 peaks from undirected <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> insertions. Our sample file is HCT-116_PBase.ccf, which contains insertions from 10 replicates of bulk RNA calling cards in the HCT-116 cell line. This file contains 1.5 million insertions:<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">\u276f wc -l HCT-116_PBase.ccf<\/div><div class = \"text-block\">1521048 HCT-116_PBase.ccf<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879266,"guid":"FA056C7048A311EA82FCE1C3EC53666F","previous_id":879265,"previous_guid":"E4ED9A2048A211EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"0DEC054439F54E67B4FC8014AEAABA2B","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling BRD4 Peaks"}},{"id":1054724,"guid":"6806A5B24ECE496D813CBF0A79B4D216","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">We start by creating creating blocks from the CCF file. To do this, we use the SegmentCCF.py script:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python SegmentCCF.py HCT-116_PBase.ccf | sed -e '\/^\\s*$\/d' > HCT-116_PBase.blocks<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">The output file is a BED-formatted list of blocks inferred by Bayesian blocks. The piped sed command simply removes blank lines.<\/div><\/div>"}},{"id":1054725,"guid":"521B53CC5C8447AB902F6D6DBBA62881","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">You may see a warning about false positive rates for event data, as well as possibly a dividing by zero warning. These are automatically generated by astropy, the library which contains the Bayesian blocks algorithm and can be safely ignored. We have successfully called peaks with the blocks generated despite these warnings.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}},{"id":1054726,"guid":"141373E6587E41D59B8BE523B721E7BD","order_id":3,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">Segmenting the CCF file is often the most time-consuming step. The Bayesian blocks algorithm has quadratic runtime complexity. If one CCF file has twice as many insertions as another, the former is expected to take roughly four times longer to segment as the latter.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879267,"guid":"D30D4F5048A511EA82FCE1C3EC53666F","previous_id":879266,"previous_guid":"FA056C7048A311EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"90F44DBBC5A64E648C615432BD846F41","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling BRD4 Peaks"}},{"id":1054724,"guid":"16A8F329BA8949F8A7132F15474325D2","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">We then provide the CCF and blocks files, as well as the TTAA file, to BBPeakCaller_BRD4.py, which tests each block for statistical significance. This script performs the following steps:<\/div><div class = \"text-block\"><ol style = \"list-style-type: decimal;\"><li style = \"counter-reset:ol0;\"><span>Divide the number of insertions by the number of TTAAs in the TTAA file. This defines a global rate parameter (<\/span><span style = \"font-style:italic;\">r<\/span><span>) under a null model assuming a uniform distribution of insertions.<\/span><\/li><li style = \"counter-reset:ol0;\"><span>For each block <\/span><span style = \"font-style:italic;\">b<\/span><span>, count the number of TTAAs in <\/span><span style = \"font-style:italic;\">b<\/span><span> and multiply it by <\/span><span style = \"font-style:italic;\">r<\/span><span>. This value specifies the expected number of insertions in <\/span><span style = \"font-style:italic;\">b<\/span><span> if insertions were uniformly distribution (denoted <\/span><span style = \"font-style:italic;vertical-align:sub;\">\u03bb<\/span><span style = \"font-style:italic;vertical-align:sub;\">b<\/span><span>).<\/span><\/li><li style = \"counter-reset:ol0;\"><span>For each block <\/span><span style = \"font-style:italic;\">b<\/span><span>, let <\/span><span style = \"font-style:italic;vertical-align:sub;\">x<\/span><span style = \"font-style:italic;vertical-align:sub;\">b<\/span><span> be the number of observed insertions in the block. The script then performs a one-tailed Poisson significance test on the block. This is calculated as the probability of observing <\/span><span style = \"font-style:italic;vertical-align:sub;\">x<\/span><span style = \"font-style:italic;vertical-align:sub;\">b<\/span><span> insertions or more in the block parametrized by a Poisson distribution with expected value <\/span><span style = \"font-style:italic;vertical-align:sub;\">\u03bb<\/span><span style = \"font-style:italic;vertical-align:sub;\">b<\/span><span style = \"font-style:italic;vertical-align:sub;\">.<\/span><span style = \"font-style:italic;\"><\/span><\/li><li style = \"counter-reset:ol0;\">Multiple hypothesis correction is performed (based on user preferences).<\/li><li style = \"counter-reset:ol0;\">Finally, blocks that pass multiple hypothesis correction are polished and written to file. The output file is in BED format.<\/li><\/ol><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879268,"guid":"F93623A048A511EA82FCE1C3EC53666F","previous_id":879261,"previous_guid":"6D279F40489D11EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"97FAE9733F39493CB41309DF7DF294FF","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preprocessing"}},{"id":1054724,"guid":"423702E6B804427FA7D08DBA9A8E76A7","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">The TTAA file only needs to be generated once per genome. Afterwards, all experiments using the same reference genome can use the same TTAA file.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879271,"guid":"3971707048A911EA82FCE1C3EC53666F","previous_id":879267,"previous_guid":"D30D4F5048A511EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"822329631E9E4DE5BFB0A5ECE18C0D6D","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling BRD4 Peaks"}},{"id":1054724,"guid":"6EFB54F28DE84E7EAB7FDE0DE2C2EA76","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">BBPeakCaller_BRD4.py takes four required positional arguments: CCF file, blocks file, TTAA file, and output filename. An example command would look like this:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python BBPeakCaller_BRD4.py HCT-116_PBase.ccf HCT-116_PBase.blocks hg38_TTAA_canon.bed HCT-116_PBase_peaks.bed<\/div><\/div><\/code><\/pre><\/div><\/div>"}},{"id":1054725,"guid":"1E55091193FD4279934FE9EF521A1B41","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\"><span>This command <\/span><span style = \"font-weight:bold;\">WILL NOT RUN<\/span><span> as written because it does not specify how peaks should be thresholded. See Step 12 for details.<\/span><\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879272,"guid":"AB5AF80048A911EA82FCE1C3EC53666F","previous_id":879271,"previous_guid":"3971707048A911EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"9D4C5A16B45D468481862EA70EF5198E","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling BRD4 Peaks"}},{"id":1054724,"guid":"F487832102EF42FFA3D00A82D2E2F25F","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-weight:bold;\">Required flag:<\/span><\/div><div class = \"text-block\">BBPeakCaller_BRD4.py has one required flag which specifies the statistical threshold for filtering blocks. There are two options for this: a straight p-value cutoff or with a multiple hypothesis correction method. The former is specified by the \u2013p flag; the value supplied to it must be the \u2013log10 transformation of the desired p-value.<\/div><div class = \"text-block\"><span>Example: select only those blocks with p < 10<\/span><span style = \"vertical-align:super;\">-9<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-p 9<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>Alternatively, you can control for multiple hypotheses at a desired alpha level. This is specified by the \u2013a flag and the value supplied is <\/span><span style = \"font-weight:bold;\">not<\/span><span> transformed. If this option is used, you must supply a method (\u2013m) of multiple hypothesis correction. Valid methods are listed <\/span><\/div><div class = \"text-block\"><a href=\"https:\/\/www.statsmodels.org\/stable\/generated\/statsmodels.stats.multitest.multipletests.html\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">here<\/span><\/a><\/div><div class = \"text-block\">.<\/div><div class = \"text-block\">Example: Bonferroni correction at an alpha of 0.05<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-a 0.05 -m bonferroni<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Example: Benjamini-Hochberg correction at false discovery rate of 10%<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-a 0.1 -m fdr_bh<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span style = \"font-weight:bold;\">Optional flags:<\/span><\/div><div class = \"text-block\"><span>Mutliple significant blocks may occur in close proximity to one another. If you want to merge these into larger peaks, you can specify a<\/span><span style = \"font-weight:bold;\"> distance (\u2013d)<\/span><span>. Significant blocks within this distance will be merged together.<\/span><\/div><div class = \"text-block\">Example: merge blocks within 12.5 kb<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-d 12500<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>Finally, while the primary output of BBPeakCaller_BRD4.py is a list of peaks in BED format, an<\/span><span style = \"font-weight:bold;\"> intermediate filename (-i)<\/span><span> can be supplied to write information about each block and it's p-value. This file will be written in CSV format.<\/span><\/div><div class = \"text-block\">Example: write an intermediate file for the HCT-116 PBase dataset<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-i HCT-116_PBase_intermediate.csv<\/div><\/div><\/code><\/pre><\/div><\/div>"}},{"id":1054725,"guid":"7D0F089F1381468DB006FFAAF815C1D9","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-weight:bold;\">Remember: <\/span><span>You must use <\/span><span style = \"font-weight:bold;\">EITHER<\/span><span> \u2013p <\/span><span style = \"font-weight:bold;\">OR<\/span><span> \u2013a \u2013m for the program to run.<\/span><\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}},{"id":1054726,"guid":"7AE840CD28614438B81F178055ED4CF1","order_id":3,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">BRD4 peaks may require choosing a p-value cutoff that is more stringent than, for example, Bonferroni correction. This appears to scale with size of the dataset: with more insertions, a more stringent cutoff is needed. To guide settling on an optimal p-value, we recommend calling peaks at a variety of cutoffs, visualizing CCF data and peak files (eg. on the WashU Epigenome Browser), and choosing a value whose peak boundaries reasonably accord with insertion densities.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879273,"guid":"C46FBA2048AD11EA82FCE1C3EC53666F","previous_id":879679,"previous_guid":"FE1C1F60496211EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"723BA396146E4641BEC1E475BAC29D74","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling BRD4 Peaks"}},{"id":1054724,"guid":"462C51963692464B96AFBEA47B7D118B","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Let's put this all together. Here is the command to recreate our analysis from our recent preprint:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python BBPeakCaller_BRD4.py -p 30 -d 12500 HCT-116_PBase.ccf HCT-116_PBase.blocks hg38_TTAA_canon.bed HCT-116_PBase_peaks.bed<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">This generates a BED file containing nearly 2000 peaks.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">\u276f wc -l HCT-116_PBase_peaks.bed<\/div><div class = \"text-block\">1939 HCT-116_PBase_peaks.bed<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879274,"guid":"9A54F5B048AE11EA82FCE1C3EC53666F","previous_id":879680,"previous_guid":"F9732200496811EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"D41BDEB766A24E40B46E5ADBD3F12887","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling TF Peaks"}},{"id":1054724,"guid":"AC4A86B3D0604D79884EDCFD03B1315E","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Peak calling on TF-directed <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> insertions is similar to calling BRD4 peaks. The major distinction is in the choice of background model. With undirected <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span>, the background is modeled as a uniform distribution of the observed number of insertions. For TF-directed <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span>, however, the background is the undirected <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> dataset from the same cell line or system.<\/span><\/div><div class = \"text-block\"><span>For this example, we will use HCT-116_SP1-PBase.ccf. This file was generated from 10 replicates of bulk RNA calling cards with SP1-<\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> in HCT-116 cells. The control file is the undirected <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> data from the same system, i.e. HCT-116_PBase.ccf.<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">\u276f wc -l HCT-116_SP1-PBase.ccf<\/div><div class = \"text-block\">410588 HCT-116_SP1-PBase.ccf<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879275,"guid":"5477695048AF11EA82FCE1C3EC53666F","previous_id":879274,"previous_guid":"9A54F5B048AE11EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"B2D5034531404F7691CA3B9434D13887","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling TF Peaks"}},{"id":1054724,"guid":"AD4E2CD6FB2A49278398DF2BE7F2E342","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">As before, we start by creating creating blocks from the CCF file:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python SegmentCCF.py HCT-116_SP1-PBase.ccf | sed -e '\/^\\s*$\/d' > HCT-116_SP1-PBase.blocks<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">The same notes from Step 9 apply here as well.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879679,"guid":"FE1C1F60496211EAA96DE1F61CA09B34","previous_id":879272,"previous_guid":"AB5AF80048A911EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"A6B059DDDD274F6FB4ED519792ACCAC6","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling BRD4 Peaks"}},{"id":1054724,"guid":"5940F67C67164BABB478D6868406910E","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">The blocks file, in addition to being used to call peaks, can also be used to calculate normalized insertion densities across the genome. This is done using the CCFIdeogram.py script, which takes as input a CCF file and a blocks file and outputs a bedgraph file. Each entry in the bedgraph file is a block and the numerical value for each block is the number of insertions in that block per million mapped insertions per kilobase (IPKM).<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python CCFIdeogram.py HCT-116_PBase.ccf HCT-116_PBase.blocks HCT-116_PBase.bedgraph<\/div><\/div><\/code><\/pre><\/div><\/div>"}},{"id":1054725,"guid":"85A54734EDF740D68045A842BB490190","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">This script is named after ideograms because the resulting bedgraph files, when visualized as densities, create banding patterns that resemble karyotyped chromosomes.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879680,"guid":"F9732200496811EAA96DE1F61CA09B34","previous_id":879273,"previous_guid":"C46FBA2048AD11EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"F53DAEFAC4A6490D9FEF5C4B3420646E","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling BRD4 Peaks"}},{"id":1054724,"guid":"522DF71BB56C43DFBF41F20FF75F40ED","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Here is the output of our sample analysis as visualized on the WashU Epigenome Browser. The top track is the raw CCF data. The next track is the per-block insertion densities as calculated by CCFIdeogram.py. The third track is the same as the second but with in-browser smoothing (15 px). We then show peak boundaries at a variety of p-value thresholds, in order of increasing stringency. Notice how peaks grow, merge, shrink, and vanish at different cutoffs. The dark blue peaks track corresponds to the threshold used in the previous step. BRD4 and H3K27ac data, marks of enhancers and super-enhancers, are shown for reference.<\/div><div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/b2ab4s6w.png\" \/><\/div><\/div>"}},{"id":1054725,"guid":"7C2204C03BD5458AB6F4174EBF6972CB","order_id":2,"type_id":1,"title":"description","source":{"description":"<div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/b2ab4s6w.png\" \/><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879681,"guid":"CEACA250496B11EAA96DE1F61CA09B34","previous_id":879275,"previous_guid":"5477695048AF11EA82FCE1C3EC53666F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"9C3C41B713894F06964A4E1D2AD68CD5","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling TF Peaks"}},{"id":1054724,"guid":"94D8C1BBC92146F09943E1299414FBFC","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">We then provide the CCF and blocks files, as well as the background CCF file, to BBPeakCaller_TF.py, which tests each block for statistical significance. This script performs the following steps:<\/div><div class = \"text-block\"><ol style = \"list-style-type: decimal;\"><li style = \"counter-reset:ol0;\"><span>Divide the number of insertions in the TF CCF file by the number of insertions in the background CCF file. This defines a global scaling parameter (<\/span><span style = \"font-style:italic;\">s<\/span><span>). This enables us to account for library size differences between the TF-directed and undirected control libraries. <\/span><\/li><li style = \"counter-reset:ol0;\"><span>For each block <\/span><span style = \"font-style:italic;\">b<\/span><span>, count the number of insertions from the background CCF file in <\/span><span style = \"font-style:italic;\">b<\/span><span> and multiply it by <\/span><span style = \"font-style:italic;\">s,<\/span><span> then add a pseudocount <\/span><span style = \"font-style:italic;\">c<\/span><span>. This value specifies the normalized expected number of insertions in <\/span><span style = \"font-style:italic;\">b<\/span><span> from the undirected control experiment (denoted <\/span><span style = \"font-style:italic;vertical-align:sub;\">\u03bb<\/span><span style = \"font-style:italic;vertical-align:sub;\">b<\/span><span>).<\/span><\/li><li style = \"counter-reset:ol0;\"><span>For each block <\/span><span style = \"font-style:italic;\">b<\/span><span>, let <\/span><span style = \"font-style:italic;vertical-align:sub;\">x<\/span><span style = \"font-style:italic;vertical-align:sub;\">b<\/span><span> be the number of insertions from the TF-directed CCF file. The script then performs a one-tailed Poisson significance test on the block. This is calculated as the probability of observing <\/span><span style = \"font-style:italic;vertical-align:sub;\">x<\/span><span style = \"font-style:italic;vertical-align:sub;\">b<\/span><span> insertions or more in the block parametrized by a Poisson distribution with expected value <\/span><span style = \"font-style:italic;vertical-align:sub;\">\u03bb<\/span><span style = \"font-style:italic;vertical-align:sub;\">b<\/span><span style = \"font-style:italic;vertical-align:sub;\">.<\/span><span style = \"font-style:italic;\"><\/span><\/li><li style = \"counter-reset:ol0;\">Multiple hypothesis correction is performed (based on user preferences).<\/li><li style = \"counter-reset:ol0;\">Finally, blocks that pass multiple hypothesis correction are polished and written to file. The output file is in BED format.<\/li><\/ol><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879682,"guid":"C9459E60496C11EAA96DE1F61CA09B34","previous_id":879681,"previous_guid":"CEACA250496B11EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"5A2CA97B2E164CDC9B25B5B3A8D3A30E","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling TF Peaks"}},{"id":1054724,"guid":"7086F9B0784943389FF06BC4BEE9BD15","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">BBPeakCaller_TF.py takes four required positional arguments: TF-directed CCF file, TF-directed blocks file, undirected CCF file, and output filename. An example command would look like this:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python BBPeakCaller_TF.py HCT-116_SP1-PBase.ccf HCT-116_SP1-PBase.blocks HCT-116_PBase.ccf HCT-116_SP1-PBase_peaks.bed<\/div><\/div><\/code><\/pre><\/div><\/div>"}},{"id":1054725,"guid":"4F9BA135A33F4938A402E31E435CBDD9","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\"><span>This command <\/span><span style = \"font-weight:bold;\">WILL NOT RUN<\/span><span> as written because it does not specify how peaks should be thresholded. See Step 20 for details.<\/span><\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879683,"guid":"5B04C190496E11EAA96DE1F61CA09B34","previous_id":879682,"previous_guid":"C9459E60496C11EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"AFDEF65D89D2404B88C6B5D06F938CB9","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling TF Peaks"}},{"id":1054724,"guid":"26E02F87C5484C91B406A1B03CCEC564","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-weight:bold;\">Required flag:<\/span><\/div><div class = \"text-block\">BBPeakCaller_TF.py has one required flag which specifies the statistical  threshold for filtering blocks. There are two options for this: a straight p-value cutoff or with a multiple hypothesis correction method. The former is specified by the \u2013p flag; the value supplied to it must be the \u2013log10 transformation of the desired p-value.<\/div><div class = \"text-block\"><span>Example: select only those blocks with p < 10<\/span><span style = \"vertical-align:super;\">-9<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-p 9<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>Alternatively, you can control for multiple hypotheses at a desired alpha level. This is specified by the \u2013a flag and the value supplied is <\/span><span style = \"font-weight:bold;\">not<\/span><span> transformed. If this option is used, you must supply a method (\u2013m) of multiple hypothesis correction. Valid methods are listed <\/span><\/div><div class = \"text-block\"><a href=\"https:\/\/www.statsmodels.org\/stable\/generated\/statsmodels.stats.multitest.multipletests.html\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">here<\/span><\/a><\/div><div class = \"text-block\">.<\/div><div class = \"text-block\">Example: Bonferroni correction at an alpha of 0.05<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-a 0.05 -m bonferroni<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Example: Benjamini-Hochberg correction at false discovery rate of 10%<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-a 0.1 -m fdr_bh<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span style = \"font-weight:bold;\">Optional flags:<\/span><\/div><div class = \"text-block\"><span>Mutliple significant blocks may occur in close proximity to one another. If you want to merge these into larger peaks, you can specify a <\/span><span style = \"font-weight:bold;\">distance (\u2013d)<\/span><span>. Significant blocks within this distance will be merged together.<\/span><\/div><div class = \"text-block\">Example: merge blocks within 250 bp<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-d 250<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>Peaks are composed of one or more blocks. Bayesian blocks draws block boundaries halfway between adjacent insertions. This can, in some cases, lead to unnecessarily wide peaks. The <\/span><span style = \"font-weight:bold;\">refine (\u2013r)<\/span><span> flag constrains the block edges so that they start and end at insertions. This, in turn, helps increase the resolution of peak calls.<\/span><\/div><div class = \"text-block\"><span>Peaks can be further filtered based on a size threshold. You can specify a <\/span><span style = \"font-weight:bold;\">minimum (\u2013n)<\/span><span> and <\/span><span style = \"font-weight:bold;\">maximum (\u2013x) <\/span><span>size bound on reported peaks.<\/span><\/div><div class = \"text-block\">Example: report all peaks less than 5 kb in length<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-x 5000<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Example: report only peaks between 100 and 500 bp in length<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-n 100 -x 500<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>By default, the pseudocount added to all peaks is 1. This <\/span><span style = \"font-weight:bold;\">value (\u2013c)<\/span><span> can be changed if desired.<\/span><\/div><div class = \"text-block\">Example: use a pseudocount of 0.1<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-c 0.1<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>Finally, while the primary output of BBPeakCaller_TF.py is a list of peaks in BED format, an<\/span><span style = \"font-weight:bold;\"> intermediate filename (-i)<\/span><span> can be supplied to write information about each block and it's p-value. This file will be written in CSV format.<\/span><\/div><div class = \"text-block\">Example: write an intermediate file for the HCT-116 SP1-PBase dataset<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">-i HCT-116_SP1-PBase_intermediate.csv<\/div><\/div><\/code><\/pre><\/div><\/div>"}},{"id":1054725,"guid":"C05363F59647417CA38403D5121BFD6D","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-weight:bold;\">Remember: <\/span><span>You must use <\/span><span style = \"font-weight:bold;\">EITHER<\/span><span> \u2013p <\/span><span style = \"font-weight:bold;\">OR<\/span><span> \u2013a \u2013m for the program to run.<\/span><\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}},{"id":1054726,"guid":"F6885D8E6E7F40AFB72C119898FA9334","order_id":3,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\"><span>TF-<\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> fusions redirect, but do not abolish, <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span>'s natural affinity for BRD4. This is why TF-directed experiments must use an undirected calling card experiment as a control. This can also pose a challenge for peak calling: whereas most TF's have narrow, sharp peaks, BRD4 can bind much broader stretches of the genome. Peak calling may not completely eliminate this signal, which is typically reflected in large, but statisically significant, peaks. Broad peaks can also occur in the shoulder regions flanking a TF binding site, likely from \"spillover\" of insertions by the increased local concentration of transposase.<\/span><\/div><div class = \"text-block\">A simple way to increase peak specificity is to threshold on peak size. In our experience, in a number of cell lines with a variety of TFs, 5 kb is a reasonable upper bound for filtering peaks. This threshold is greater than the median peak sizes we have observed, which lets us preserve the majority of called peaks.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879684,"guid":"847052E0497011EAA96DE1F61CA09B34","previous_id":879683,"previous_guid":"5B04C190496E11EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"CA4170C70BB947B1879A26A2F8BAA14D","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling TF Peaks"}},{"id":1054724,"guid":"8C581D867E0844DEAC91C288600E1E34","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">As before, TF-directed CCF files can also be used to create insertion density tracks, following the instructions in Step 13.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879685,"guid":"BA766EB0497011EAA96DE1F61CA09B34","previous_id":879684,"previous_guid":"847052E0497011EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"1AA7C6D1AC9D4B73B6B40DA145F6C738","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling TF Peaks"}},{"id":1054724,"guid":"46568840A5DE4A09904EFEE16ED0583F","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Let's put this all together. This command calls peaks from SP1-PBase at a false discovery rate of 5%, merging significant blocks within 250 bp, refining block edges, and outputing all peaks less than 5 kb in length:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python BBPeakCaller_TF.py -a 0.05 -m fdr_bh -d 250 -r -x 5000 HCT-116_SP1-PBase.ccf HCT-116_SP1-PBase.blocks HCT-116_PBase.ccf HCT-116_SP1-PBase_peaks.bed<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">This generates a BED file containing around 5600 peaks.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">\u276f wc -l HCT-116_SP1-PBase_peaks.bed<\/div><div class = \"text-block\">5615 HCT-116_SP1-PBase_peaks.bed<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879686,"guid":"2BA95B00497211EAA96DE1F61CA09B34","previous_id":879685,"previous_guid":"BA766EB0497011EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"2042BC5B843942D6914F8A188119086C","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calling TF Peaks"}},{"id":1054724,"guid":"250635CF700A4904B69BE29143C18897","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Here is the output of our sample analysis as visualized on the WashU Epigenome Browser. The top track are the undirected insertions, followed by the SP1-directed insertions. The next track is the per-block insertion densities for the SP1-PBase data with in-browser smoothing (3 px). Finally, we plot peak boundaries at a variety of p-value thresholds, in order of decreasing stringency. Notice how peaks grow, merge, shrink, and vanish at different cutoffs. The dark blue peaks track corresponds to the threshold used in the previous step. The dark blue track shows all significant peaks at 5% FDR less then 5 kb in length. The light blue track shows all peaks without size restriction. Notice how imposing a maximum peak size filters out potentially artifactual peaks.<\/div><div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/bydj4s6w.png\" \/><\/div><\/div>"}},{"id":1054725,"guid":"1E714AFA2A744AC28108A2F55AC099E3","order_id":2,"type_id":1,"title":"description","source":{"description":"<div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/bydj4s6w.png\" \/><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879687,"guid":"F9066330497811EAA96DE1F61CA09B34","previous_id":879688,"previous_guid":"D4B51890497911EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"FB71BFB7CB8E410AB0C9179F701690E5","order_id":1,"type_id":6,"title":"Section","source":{"title":"Final Thoughts"}},{"id":1054724,"guid":"FB77175FEBA74E5BA75B4B5A552708E2","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">The output of these peak calling scripts are BED files listing peak coordinates only. They do not annotate the peaks themselves. There are a number of programs for secondary analyses:<\/div><div class = \"text-block\">Peaks can be annotated with overlapping and nearest genes using <\/div><div class = \"text-block\"><a href=\"http:\/\/homer.ucsd.edu\/homer\/\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">HOMER<\/span><\/a><\/div><div class = \"text-block\">.<\/div><div class = \"text-block\">Peaks can be connected to putative genetic targets using <\/div><div class = \"text-block\"><a href=\"http:\/\/great.stanford.edu\/public\/html\/\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">GREAT<\/span><\/a><\/div><div class = \"text-block\">.<\/div><div class = \"text-block\"><span style = \"font-style:italic;\">De novo<\/span><span> motif analysis on peaks can be done with either <\/span><\/div><div class = \"text-block\"><a href=\"http:\/\/homer.ucsd.edu\/homer\/\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">HOMER<\/span><\/a><\/div><div class = \"text-block\"> or <\/div><div class = \"text-block\"><a href=\"http:\/\/meme-suite.org\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">MEME<\/span><\/a><\/div><div class = \"text-block\">.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":879688,"guid":"D4B51890497911EAA96DE1F61CA09B34","previous_id":879686,"previous_guid":"2BA95B00497211EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"91C19AD9DCCD43438A88AF41ADB925D7","order_id":1,"type_id":6,"title":"Section","source":{"title":"Final Thoughts"}},{"id":1054724,"guid":"B547930C5B884913BC97B37A78C0F520","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">BBPeakCaller_TF.py can also be used to call differential peaks between two different undirected or TF-directed calling card datasets, such as between cell types or treatments. In this use case, one sample serves as the \"background\" for the other. For example, let's imagine that we have done one undirected (a.k.a. BRD4) calling cards experiment on cells treated with DMSO and another treated with dexamethasone. To identify peaks that are enriched in the dexamethasone condition, we could call:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python BBPeakCaller_TF.py -p 9 -d 12500 DEX.ccf DEX.blocks DMSO.ccf DEX_peaks.bed<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Since these tests are one-tailed, to find peaks that are enriched in the other direction, i.e. in the DMSO condition, we simply swap the datasets:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python BBPeakCaller_TF.py -p 9 -d 12500 DMSO.ccf DMSO.blocks DEX.ccf DMSO_peaks.bed<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":880125,"guid":"2D82E64049D011EA86694BDFA9481160","previous_id":879687,"previous_guid":"F9066330497811EAA96DE1F61CA09B34","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"D19177C194D44CCE9AB334AA616BC09C","order_id":1,"type_id":6,"title":"Section","source":{"title":"Final Thoughts"}},{"id":1054724,"guid":"D6BC89A7E79346239BE699779FFF36ED","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">For guidance on how to visualize calling card data, see our <\/div><div class = \"text-block\"><a href=\"https:\/\/protocols.io\/view\/visualizing-calling-card-data-on-the-washu-epigeno-bca8ishw\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">companion protocol<\/span><\/a><\/div><div class = \"text-block\">. Documentation is also available from the <\/div><div class = \"text-block\"><a href=\"https:\/\/eg.readthedocs.io\/en\/latest\/\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">WashU Epigenome Browser<\/span><\/a><\/div><div class = \"text-block\">.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","section_duration":0,"critical":null,"critical_id":null,"duration":0}],"document":null,"materials":[],"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>This protocol describes how to all peaks on mammalian calling card data using either undirected, or transcription factor fusions, to the <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> transposase. It is applicable for both bulk as well as single cell calling card data.<\/span><\/div><\/div>","changed_on":1583874707}